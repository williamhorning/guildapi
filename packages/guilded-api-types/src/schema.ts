// autogenerated by @jersey/openapi

/**
 * @description ChatMessage
 */
export type ChatMessage = {
	/** @description The ID of the message */
	id: string;
	/** @description The type of chat message. "system" messages are generated by Guilded, while "default" messages are user or bot-generated. */
	type: 'default' | 'system';
	/** @description The ID of the server */
	serverId?: string;
	/** @description The ID of the group */
	groupId?: string;
	/** @description The ID of the channel */
	channelId: string;
	/** @description The content of the message */
	content?: string;
	/** @description Links in `content` to prevent unfurling as a link preview when displaying in Guilded */
	hiddenLinkPreviewUrls?: (string)[];
	/** @description embeds */
	embeds?: (ChatEmbed)[];
	/** @description Message IDs that were replied to */
	replyMessageIds?: (string)[];
	/** @description If set, this message will only be seen by those mentioned or replied to */
	isPrivate?: boolean;
	/** @description If set, this message did not notify mention or reply recipients */
	isSilent?: boolean;
	/** @description Is pinned */
	isPinned?: boolean;
	/** @description mentions */
	mentions?: Mentions;
	/** @description The ISO 8601 timestamp that the message was created at */
	createdAt: string;
	/** @description The ID of the user who created this message (Note: If this event has `createdByWebhookId` present, this field will still be populated, but can be ignored. In this case, the value of this field will always be Ann6LewA) */
	createdBy: string;
	/** @description The ID of the webhook who created this message, if it was created by a webhook */
	createdByWebhookId?: string;
	/** @description The ISO 8601 timestamp that the message was updated at, if relevant */
	updatedAt?: string;
};

/**
 * @description ChatMessageReaction
 */
export interface ChatMessageReaction {
	/** @description The ID of the channel */
	channelId: string;
	/** @description The ID of the user who added the reaction */
	createdBy: string;
	/** @description emote */
	emote: Emote;
	/** @description The ID of the message */
	messageId: string;
}

/**
 * @description Rich content sections optionally associated with chat messages. Properties with "webhook-markdown" support allow for the following: link, italic, bold, strikethrough, underline, inline code, block code, reaction, mention, and role mention.
 */
export interface ChatEmbed {
	/** @description Main header of the embed */
	title?: string;
	/** @description Subtext of the embed */
	description?: string;
	/** @description URL to linkify the `title` field with */
	url?: string;
	/** @description The integer value corresponds to the decimal RGB representation for the color. The color that the left border should be */
	color?: number;
	/** @description A small section at the bottom of the embed */
	footer?: {
		icon_url?: string;
		text: string;
	};
	/** @description A timestamp to put in the footer */
	timestamp?: string;
	/** @description An image to the right of the embed's content */
	thumbnail?: {
		url?: string;
	};
	/** @description The main picture to associate with the embed */
	image?: {
		url?: string;
	};
	/** @description A small section above the title of the embed */
	author?: {
		name?: string;
		url?: string;
		icon_url?: string;
	};
	/** @description Table-like cells to add to the embed */
	fields?: ({
		name: string;
		value: string;
		inline?: boolean;
	})[];
}

/**
 * @description SocialLink
 */
export interface SocialLink {
	/** @description The type of social link that Guilded supports. Depending on this value, `handle` or `serviceId` may or may not be present */
	type:
		| 'twitch'
		| 'bnet'
		| 'psn'
		| 'xbox'
		| 'steam'
		| 'origin'
		| 'youtube'
		| 'twitter'
		| 'facebook'
		| 'switch'
		| 'patreon'
		| 'roblox'
		| 'epic';
	/** @description The ID of the user that the social link is associated with */
	userId: string;
	/** @description The handle of the user within the external service */
	handle?: string;
	/** @description The unique ID that represents this member's social link within the external service */
	serviceId?: string;
	/** @description The ISO 8601 timestamp that the social link was created at */
	createdAt: string;
}

/**
 * @description Metadata of who or what is mentioned in content
 */
export type Mentions = {
	/** @description Info on mentioned users */
	users?: ({
		id: string;
	})[];
	/** @description Info on mentioned channels */
	channels?: ({
		id: string;
	})[];
	/** @description Info on mentioned roles */
	roles?: ({
		id: number;
	})[];
	/** @description If @everyone was mentioned */
	everyone?: boolean;
	/** @description If @here was mentioned */
	here?: boolean;
};

/**
 * @description ForumTopicComment
 */
export interface ForumTopicComment {
	/** @description The ID of the forum topic comment */
	id: number;
	/** @description The content of the forum topic comment */
	content: string;
	/** @description The ISO 8601 timestamp that the forum topic comment was created at */
	createdAt: string;
	/** @description The ISO 8601 timestamp that the forum topic comment was updated at, if relevant */
	updatedAt?: string;
	/** @description The ID of the channel */
	channelId: string;
	/** @description The ID of the forum topic */
	forumTopicId: number;
	/** @description The ID of the user who created this forum topic comment (Note: If this event has `createdByWebhookId` present, this field will still be populated, but can be ignored. In this case, the value of this field will always be Ann6LewA) */
	createdBy: string;
	/** @description mentions */
	mentions?: Mentions;
}

/**
 * @description ForumTopicReaction
 */
export interface ForumTopicReaction {
	/** @description The ID of the channel */
	channelId: string;
	/** @description The ID of the user who added the reaction */
	createdBy: string;
	/** @description emote */
	emote: Emote;
	/** @description The ID of the forum topic */
	forumTopicId: number;
}

/**
 * @description ForumTopicCommentReaction
 */
export interface ForumTopicCommentReaction {
	/** @description The ID of the channel */
	channelId: string;
	/** @description The ID of the user who added the reaction */
	createdBy: string;
	/** @description emote */
	emote: Emote;
	/** @description The ID of the forum topic */
	forumTopicId: number;
	/** @description The ID of the forum topic comment */
	forumTopicCommentId: number;
}

/**
 * @description ForumTopic
 */
export interface ForumTopic {
	/** @description The ID of the forum topic */
	id: number;
	/** @description The ID of the server */
	serverId: string;
	/** @description The ID of the group */
	groupId: string;
	/** @description The ID of the channel */
	channelId: string;
	/** @description The title of the forum topic */
	title: string;
	/** @description The ISO 8601 timestamp that the forum topic was created at */
	createdAt: string;
	/** @description The ID of the user who created this forum topic (Note: If this event has `createdByWebhookId` present, this field will still be populated, but can be ignored. In this case, the value of this field will always be Ann6LewA) */
	createdBy: string;
	/** @description The ISO 8601 timestamp that the forum topic was updated at, if relevant */
	updatedAt?: string;
	/** @description The ISO 8601 timestamp that the forum topic was bumped at. This timestamp is updated whenever there is any activity on the posts within the forum topic. */
	bumpedAt?: string;
	/** @description Is pinned */
	isPinned?: boolean;
	/** @description Is locked */
	isLocked?: boolean;
	/** @description The content of the forum topic */
	content: string;
	/** @description mentions */
	mentions?: Mentions;
}

/**
 * @description ForumTopicSummary
 */
export interface ForumTopicSummary {
	/** @description The ID of the forum topic */
	id: number;
	/** @description The ID of the server */
	serverId: string;
	/** @description The ID of the group */
	groupId: string;
	/** @description The ID of the channel */
	channelId: string;
	/** @description The title of the forum topic */
	title: string;
	/** @description The ISO 8601 timestamp that the forum topic was created at */
	createdAt: string;
	/** @description The ID of the user who created this forum topic (Note: If this event has `createdByWebhookId` present, this field will still be populated, but can be ignored. In this case, the value of this field will always be Ann6LewA) */
	createdBy: string;
	/** @description The ISO 8601 timestamp that the forum topic was updated at, if relevant */
	updatedAt?: string;
	/** @description The ISO 8601 timestamp that the forum topic was bumped at. This timestamp is updated whenever there is any activity on the posts within the forum topic. */
	bumpedAt?: string;
	/** @description Is pinned */
	isPinned?: boolean;
	/** @description Is locked */
	isLocked?: boolean;
}

/**
 * @description ListItem
 */
export interface ListItem {
	/** @description The ID of the list item */
	id: string;
	/** @description The ID of the server */
	serverId: string;
	/** @description The ID of the group */
	groupId: string;
	/** @description The ID of the channel */
	channelId: string;
	/** @description The message of the list item */
	message: string;
	/** @description mentions */
	mentions?: Mentions;
	/** @description The ISO 8601 timestamp that the list item was created at */
	createdAt: string;
	/** @description The ID of the user who created this list item (Note: If this event has `createdByWebhookId` present, this field will still be populated, but can be ignored. In this case, the value of this field will always be Ann6LewA) */
	createdBy: string;
	/** @description The ID of the webhook who created this list item, if it was created by a webhook */
	createdByWebhookId?: string;
	/** @description The ISO 8601 timestamp that the list item was updated at, if relevant */
	updatedAt?: string;
	/** @description The ID of the user who updated this list item */
	updatedBy?: string;
	/** @description The ID of the parent list item if this list item is nested */
	parentListItemId?: string;
	/** @description The ISO 8601 timestamp that the list item was completed at */
	completedAt?: string;
	/** @description The ID of the user who completed this list item */
	completedBy?: string;
	/** @description note */
	note?: {
		createdAt: string;
		createdBy: string;
		updatedAt?: string;
		updatedBy?: string;
		mentions?: Mentions;
		content: string;
	};
}

/**
 * @description ListItemSummary
 */
export interface ListItemSummary {
	/** @description The ID of the list item */
	id: string;
	/** @description The ID of the server */
	serverId: string;
	/** @description The ID of the channel */
	channelId: string;
	/** @description The message of the list item */
	message: string;
	/** @description mentions */
	mentions?: Mentions;
	/** @description The ISO 8601 timestamp that the list item was created at */
	createdAt: string;
	/** @description The ID of the user who created this list item (Note: If this event has `createdByWebhookId` present, this field will still be populated, but can be ignored. In this case, the value of this field will always be Ann6LewA) */
	createdBy: string;
	/** @description The ID of the webhook who created this list item, if it was created by a webhook */
	createdByWebhookId?: string;
	/** @description The ISO 8601 timestamp that the list item was updated at, if relevant */
	updatedAt?: string;
	/** @description The ID of the user who updated this list item */
	updatedBy?: string;
	/** @description The ID of the parent list item if this list item is nested */
	parentListItemId?: string;
	/** @description The ISO 8601 timestamp that the list item was completed at */
	completedAt?: string;
	/** @description The ID of the user who completed this list item */
	completedBy?: string;
	/** @description note */
	note?: {
		createdAt: string;
		createdBy: string;
		updatedAt?: string;
		updatedBy?: string;
	};
}

/**
 * @description Doc
 */
export interface Doc {
	/** @description The ID of the doc */
	id: number;
	/** @description The ID of the server */
	serverId: string;
	/** @description The ID of the group */
	groupId: string;
	/** @description The ID of the channel */
	channelId: string;
	/** @description The title of the doc */
	title: string;
	/** @description The content of the doc */
	content: string;
	/** @description mentions */
	mentions?: Mentions;
	/** @description The ISO 8601 timestamp that the doc was created at */
	createdAt: string;
	/** @description The ID of the user who created this doc */
	createdBy: string;
	/** @description The ISO 8601 timestamp that the doc was updated at, if relevant */
	updatedAt?: string;
	/** @description The ID of the user who updated this doc */
	updatedBy?: string;
}

/**
 * @description DocComment
 */
export interface DocComment {
	/** @description The ID of the doc comment */
	id: number;
	/** @description The content of the doc comment */
	content: string;
	/** @description The ISO 8601 timestamp that the doc comment was created at */
	createdAt: string;
	/** @description The ID of the user who created this doc comment (Note: If this event has `createdByWebhookId` present, this field will still be populated, but can be ignored. In this case, the value of this field will always be Ann6LewA) */
	createdBy: string;
	/** @description The ISO 8601 timestamp that the doc comment was updated at, if relevant */
	updatedAt?: string;
	/** @description The ID of the channel */
	channelId: string;
	/** @description The ID of the doc */
	docId: number;
	/** @description mentions */
	mentions?: Mentions;
}

/**
 * @description DocReaction
 */
export interface DocReaction {
	/** @description The ID of the channel */
	channelId: string;
	/** @description The ID of the user who added the reaction */
	createdBy: string;
	/** @description emote */
	emote: Emote;
	/** @description The ID of the doc */
	docId: number;
}

/**
 * @description DocCommentReaction
 */
export interface DocCommentReaction {
	/** @description The ID of the channel */
	channelId: string;
	/** @description The ID of the user who added the reaction */
	createdBy: string;
	/** @description emote */
	emote: Emote;
	/** @description The ID of the doc */
	docId: number;
	/** @description The ID of the doc comment */
	docCommentId: number;
}

/**
 * @description ServerMember
 */
export interface ServerMember {
	/** @description user */
	user: User;
	/** @description Role IDs */
	roleIds: (number)[];
	/** @description Nickname */
	nickname?: string;
	/** @description The ISO 8601 timestamp that the member was created at */
	joinedAt: string;
	/** @description Is owner */
	isOwner?: boolean;
}

/**
 * @description ServerMemberSummary
 */
export interface ServerMemberSummary {
	/** @description user */
	user: UserSummary;
	/** @description Role IDs */
	roleIds: (number)[];
}

/**
 * @description User
 */
export interface User {
	/** @description The ID of the user */
	id: string;
	/** @description The type of user. If this property is absent, it can assumed to be of type `user` */
	type?: 'bot' | 'user';
	/** @description The user's name */
	name: string;
	/** @description The avatar image associated with the user */
	avatar?: string;
	/** @description The banner image associated with the user */
	banner?: string;
	/** @description The ISO 8601 timestamp that the user was created at */
	createdAt: string;
	/** @description status */
	status?: UserStatus;
}

/**
 * @description UserSummary
 */
export interface UserSummary {
	/** @description The ID of the user */
	id: string;
	/** @description The type of user. If this property is absent, it can assumed to be of type `user` */
	type?: 'bot' | 'user';
	/** @description The user's name */
	name: string;
	/** @description The avatar image associated with the user */
	avatar?: string;
}

/**
 * @description ServerMemberBan
 */
export interface ServerMemberBan {
	/** @description user */
	user: UserSummary;
	/** @description The reason for the ban as submitted by the banner */
	reason?: string;
	/** @description The ID of the user who created this server member ban */
	createdBy: string;
	/** @description The ISO 8601 timestamp that the server member ban was created at */
	createdAt: string;
}

/**
 * @description ServerChannel
 */
export interface ServerChannel {
	/** @description The ID of the channel */
	id: string;
	/** @description The type of channel. This will determine what routes to use for creating content in a channel. For example, if this "chat", then one must use the routes for creating channel messages */
	type:
		| 'announcements'
		| 'chat'
		| 'calendar'
		| 'forums'
		| 'media'
		| 'docs'
		| 'voice'
		| 'list'
		| 'scheduling'
		| 'stream';
	/** @description The name of the channel */
	name: string;
	/** @description The topic of the channel. Not applicable to threads */
	topic?: string;
	/** @description The ISO 8601 timestamp that the channel was created at */
	createdAt: string;
	/** @description The ID of the user who created this channel */
	createdBy: string;
	/** @description The ISO 8601 timestamp that the channel was updated at, if relevant */
	updatedAt?: string;
	/** @description The ID of the server */
	serverId: string;
	/** @description ID of the **root** channel or thread in the channel hierarchy. Only applicable to "chat", "voice", and "stream" channels and indicates that this channel is a thread, if present */
	rootId?: string;
	/** @description ID of the **immediate** parent channel or thread in the channel hierarchy. Only applicable to "chat", "voice", and "stream" channels and indicates that this channel is a thread, if present */
	parentId?: string;
	/** @description The ID of the message that this channel was created off of. Only applicable to "chat", "voice", and "stream" channels and indicates that this channel is a thread, if present */
	messageId?: string;
	/** @description The category that the channel exists in. Only relevant for server channels */
	categoryId?: number;
	/** @description The ID of the group */
	groupId: string;
	/** @description What users can access the channel. Only applicable to server channels. If not present, this channel will respect normal permissions. `public` is accessible to everyone, even those who aren't of the server. `private` is only accessible to explicitly mentioned users. Currently, threads cannot be `public` and other channels cannot be `private`. Additionally, `private` threads can only exist with an associated `messageId` that is for a private message */
	visibility?: null | 'private' | 'public';
	/** @description The ID of the user who archived this channel */
	archivedBy?: string;
	/** @description The ISO 8601 timestamp that the channel was archived at, if relevant */
	archivedAt?: string;
	/** @description The priority of the channel will determine its position relative to other categories in the group. The higher the value, the higher up it will be displayed in the UI. Returned values can be null, in which case sorting will be done by `createdAt` in ascending order. Due to legacy issues, sending a null value is not possible */
	priority?: number;
}

/**
 * @description Server
 */
export interface Server {
	/** @description The ID of the server */
	id: string;
	/** @description The ID of the user who created this server */
	ownerId: string;
	/** @description The type of server designated from the server's settings page */
	type?:
		| 'team'
		| 'organization'
		| 'community'
		| 'clan'
		| 'guild'
		| 'friends'
		| 'streaming'
		| 'other';
	/** @description The name given to the server */
	name: string;
	/** @description The URL that the server can be accessible from. For example, a value of "Guilded-Official" means the server can be accessible from https://www.guilded.gg/Guilded-Official */
	url?: string;
	/** @description The description associated with the server */
	about?: string;
	/** @description The avatar image associated with the server */
	avatar?: string;
	/** @description The banner image associated with the server */
	banner?: string;
	/** @description The timezone associated with the server */
	timezone?: string;
	/** @description The verified status of the server */
	isVerified?: boolean;
	/** @description The channel ID of the default channel of the server. This channel is defined as the first chat or voice channel in the left sidebar of a server in our UI. This channel is useful for sending welcome messages, though note that a bot may not have permissions to interact with this channel depending on how the server is configured. */
	defaultChannelId?: string;
	/** @description The ISO 8601 timestamp that the server was created at */
	createdAt: string;
}

/**
 * @description Webhook
 */
export interface Webhook {
	/** @description The ID of the webhook */
	id: string;
	/** @description The name of the webhook */
	name: string;
	/** @description The avatar image associated with the webhook */
	avatar?: string;
	/** @description The ID of the server */
	serverId: string;
	/** @description The ID of the channel */
	channelId: string;
	/** @description The ISO 8601 timestamp that the webhook was created at */
	createdAt: string;
	/** @description The ID of the user who created this webhook */
	createdBy: string;
	/** @description The ISO 8601 timestamp that the webhook was deleted at */
	deletedAt?: string;
	/** @description The token of the webhook */
	token?: string;
}

/**
 * @description CalendarEvent
 */
export interface CalendarEvent {
	/** @description The ID of the calendar event */
	id: number;
	/** @description The ID of the server */
	serverId: string;
	/** @description The ID of the group */
	groupId: string;
	/** @description The ID of the channel */
	channelId: string;
	/** @description The name of the event */
	name: string;
	/** @description The description of the event */
	description?: string;
	/** @description The location of the event */
	location?: string;
	/** @description A URL to associate with the event */
	url?: string;
	/** @description The integer value corresponds to the decimal RGB representation for the color. The color of the event when viewing in the calendar */
	color?: number;
	/** @description Is this event a repeating event */
	repeats?: boolean;
	/** @description The ID of the calendar event series. Only shows if the event is repeating */
	seriesId?: string;
	/** @description The role IDs to restrict the event to */
	roleIds?: (number)[];
	/** @description When disabled, users will not be able to RSVP to the event */
	rsvpDisabled?: boolean;
	/** @description Does the event last all day */
	isAllDay?: boolean;
	/** @description The number of RSVPs to allow before waitlisting RSVPs */
	rsvpLimit?: number;
	/** @description When `rsvpLimit` is set, users from the waitlist will be added as space becomes available in the event */
	autofillWaitlist?: boolean;
	/** @description The ISO 8601 timestamp that the event starts at */
	startsAt: string;
	/** @description The duration of the event _**in minutes**_ */
	duration?: number;
	/** @description Is private */
	isPrivate?: boolean;
	/** @description mentions */
	mentions?: Mentions;
	/** @description The ISO 8601 timestamp that the event was created at */
	createdAt: string;
	/** @description The ID of the user who created this event */
	createdBy: string;
	/** @description cancellation */
	cancellation?: {
		description?: string;
		createdBy: string;
	};
}

/**
 * @description Emote
 */
export interface Emote {
	/** @description The ID of the emote */
	id: number;
	/** @description The name of the emote */
	name: string;
	/** @description The URL of the emote image */
	url: string;
	/** @description The ID of the server the emote was created on */
	serverId?: string;
}

/**
 * @description CalendarEventRsvp
 */
export interface CalendarEventRsvp {
	/** @description The ID of the calendar event */
	calendarEventId: number;
	/** @description The ID of the channel */
	channelId: string;
	/** @description The ID of the server */
	serverId: string;
	/** @description The ID of the user */
	userId: string;
	/** @description The status of the RSVP */
	status:
		| 'going'
		| 'maybe'
		| 'declined'
		| 'invited'
		| 'waitlisted'
		| 'not responded';
	/** @description The ID of the user who created this RSVP */
	createdBy: string;
	/** @description The ISO 8601 timestamp that the RSVP was created at */
	createdAt: string;
	/** @description The ID of the user who updated this RSVP */
	updatedBy?: string;
	/** @description The ISO 8601 timestamp that the RSVP was updated at, if relevant */
	updatedAt?: string;
}

/**
 * @description CalendarEventComment
 */
export interface CalendarEventComment {
	/** @description The ID of the calendar event comment */
	id: number;
	/** @description The content of the calendar event comment */
	content: string;
	/** @description The ISO 8601 timestamp that the calendar event comment was created at */
	createdAt: string;
	/** @description The ISO 8601 timestamp that the calendar event comment was updated at, if relevant */
	updatedAt?: string;
	/** @description The ID of the calendar event */
	calendarEventId: number;
	/** @description The ID of the channel */
	channelId: string;
	/** @description The ID of the user who created this calendar event comment (Note: If this event has `createdByWebhookId` present, this field will still be populated, but can be ignored. In this case, the value of this field will always be Ann6LewA) */
	createdBy: string;
	/** @description mentions */
	mentions?: Mentions;
}

/**
 * @description CalendarEventReaction
 */
export interface CalendarEventReaction {
	/** @description The ID of the channel */
	channelId: string;
	/** @description The ID of the user who added the reaction */
	createdBy: string;
	/** @description emote */
	emote: Emote;
	/** @description The ID of the calendar event */
	calendarEventId: number;
}

/**
 * @description CalendarEventCommentReaction
 */
export interface CalendarEventCommentReaction {
	/** @description The ID of the channel */
	channelId: string;
	/** @description The ID of the user who added the reaction */
	createdBy: string;
	/** @description emote */
	emote: Emote;
	/** @description The ID of the calendar event */
	calendarEventId: number;
	/** @description The ID of the calendar event comment */
	calendarEventCommentId: number;
}

/**
 * @description CalendarEventSeries
 */
export interface CalendarEventSeries {
	/** @description The ID of the calendar event series */
	id: string;
	/** @description The ID of the server */
	serverId: string;
	/** @description The ID of the channel */
	channelId: string;
}

/**
 * @description Announcement
 */
export interface Announcement {
	/** @description The ID of the announcement */
	id: string;
	/** @description The ID of the server */
	serverId: string;
	/** @description The ID of the group */
	groupId: string;
	/** @description The ID of the channel */
	channelId: string;
	/** @description The ISO 8601 timestamp that the announcement was created at */
	createdAt: string;
	/** @description The ID of the user who created this announcement */
	createdBy: string;
	/** @description The content of the announcement */
	content: string;
	/** @description mentions */
	mentions?: Mentions;
	/** @description The title of the announcement */
	title: string;
}

/**
 * @description AnnouncementReaction
 */
export interface AnnouncementReaction {
	/** @description The ID of the channel */
	channelId: string;
	/** @description The ID of the user who added the reaction */
	createdBy: string;
	/** @description emote */
	emote: Emote;
	/** @description The ID of the announcement */
	announcementId: string;
}

/**
 * @description AnnouncementComment
 */
export interface AnnouncementComment {
	/** @description The ID of the announcement comment */
	id: number;
	/** @description The content of the announcement comment */
	content: string;
	/** @description The ISO 8601 timestamp that the announcement comment was created at */
	createdAt: string;
	/** @description The ISO 8601 timestamp that the announcement comment was updated at, if relevant */
	updatedAt?: string;
	/** @description The ID of the user who created this announcement comment (Note: If this event has `createdByWebhookId` present, this field will still be populated, but can be ignored. In this case, the value of this field will always be Ann6LewA) */
	createdBy: string;
	/** @description The ID of the channel */
	channelId: string;
	/** @description The ID of the announcement */
	announcementId: string;
	/** @description mentions */
	mentions?: Mentions;
}

/**
 * @description AnnouncementCommentReaction
 */
export interface AnnouncementCommentReaction {
	/** @description The ID of the channel */
	channelId: string;
	/** @description The ID of the user who added the reaction */
	createdBy: string;
	/** @description emote */
	emote: Emote;
	/** @description The ID of the announcement */
	announcementId: string;
	/** @description The ID of the announcement comment */
	announcementCommentId: number;
}

/**
 * @description Group
 */
export interface Group {
	/** @description The ID of the group */
	id: string;
	/** @description The ID of the server */
	serverId: string;
	/** @description The name of the group */
	name: string;
	/** @description The description associated with the group */
	description?: string;
	/** @description The avatar image associated with the group */
	avatar?: string;
	/** @description If `true`, this is the server's home group */
	isHome?: boolean;
	/** @description The emote to associate with the group */
	emoteId?: number;
	/** @description Is this group open for anyone to join? */
	isPublic?: boolean;
	/** @description The ISO 8601 timestamp that the group was created at */
	createdAt: string;
	/** @description The ID of the user who created this group */
	createdBy: string;
	/** @description The ISO 8601 timestamp that the group was updated at, if relevant */
	updatedAt?: string;
	/** @description The ID of the user who updated this group */
	updatedBy?: string;
	/** @description The ISO 8601 timestamp that the group was archived at, if relevant */
	archivedAt?: string;
	/** @description The ID of the user who archived this group */
	archivedBy?: string;
}

/**
 * @description UserStatus
 */
export interface UserStatus {
	/** @description The content of the user status. The supported markdown for this content only includes reactions and plaintext for now */
	content?: string;
	/** @description Emote ID */
	emoteId: number;
}

/**
 * @description Role
 */
export interface Role {
	/** @description The ID of the role */
	id: number;
	/** @description The ID of the server */
	serverId: string;
	/** @description The ISO 8601 timestamp that the role was created at */
	createdAt: string;
	/** @description The ISO 8601 timestamp that the role was updated at, if relevant */
	updatedAt?: string;
	/** @description The role's name */
	name: string;
	/** @description If set, the role will be displayed separately in the channel member list */
	isDisplayedSeparately?: boolean;
	/** @description If set, this roll will be self assigned */
	isSelfAssignable?: boolean;
	/** @description If set, this role can be mentioned */
	isMentionable?: boolean;
	/** @description Permissions must be a collection of valid permissions as defined in the [Enums/Permissions](https://www.guilded.gg/docs/api/Permissions) section */
	permissions: (string)[];
	/** @description An array of integer values corresponding to the decimal RGB representation for a color. The first color is solid, and a second color indicates a gradient */
	colors?: (number)[];
	/** @description The URL of the role icon */
	icon?: string;
	/** @description The priority the role will be in relation to other roles in the server. The higher the value, the more precedence the role has over lower priority roles, and the higher up it will be displayed in the UI. Values can be zero or negative! */
	priority?: number;
	/** @description The default role users are given when joining the server. Base roles are tied directly to the server and cannot be created or deleted */
	isBase?: boolean;
	/** @description The bot user ID this role has been defined for. Roles with this populated can only be deleted by kicking the bot */
	botUserId?: string;
}

/**
 * @description ServerSubscriptionTier
 */
export interface ServerSubscriptionTier {
	/** @description The type of the server subscription tier. This field is case sensitive!! */
	type: 'Gold' | 'Silver' | 'Copper';
	/** @description The ID of the server */
	serverId: string;
	/** @description The description associated with the server subscription tier */
	description?: string;
	/** @description The ID of the role */
	roleId?: number;
	/** @description The cost of the tier in cents USD per month */
	cost: number;
	/** @description The ISO 8601 timestamp that the server subscription tier was created at */
	createdAt: string;
}

/**
 * @description ServerMemberPermissions
 */
export interface ServerMemberPermissions {
	/** @description Permissions must be a collection of valid permissions as defined in the [Enums/Permissions](https://www.guilded.gg/docs/api/Permissions) section */
	permissions: (string)[];
}

/**
 * @description Category
 */
export interface Category {
	/** @description The ID of the category */
	id: number;
	/** @description The ID of the server */
	serverId: string;
	/** @description The ID of the group */
	groupId: string;
	/** @description The ISO 8601 timestamp that the category was created at */
	createdAt: string;
	/** @description The ISO 8601 timestamp that the category was updated at, if relevant */
	updatedAt?: string;
	/** @description Name of the category */
	name: string;
	/** @description The priority of the category will determine its position relative to other categories in the group. The higher the value, the higher up it will be displayed in the UI. Returned values can be null, in which case sorting will be done by `createdAt` in descending order. Due to legacy issues, sending a null value is not possible */
	priority?: number;
}

/**
 * @description ChannelRolePermission
 */
export interface ChannelRolePermission {
	/** @description permissions */
	permissions: Record<string, boolean>;
	/** @description The ISO 8601 timestamp that the permission override was created at */
	createdAt: string;
	/** @description The ISO 8601 timestamp that the permission override was updated at, if relevant */
	updatedAt?: string;
	/** @description The ID of the role */
	roleId: number;
	/** @description The ID of the channel */
	channelId: string;
}

/**
 * @description ChannelUserPermission
 */
export interface ChannelUserPermission {
	/** @description permissions */
	permissions: Record<string, boolean>;
	/** @description The ISO 8601 timestamp that the permission override was created at */
	createdAt: string;
	/** @description The ISO 8601 timestamp that the permission override was updated at, if relevant */
	updatedAt?: string;
	/** @description The ID of the user */
	userId: string;
	/** @description The ID of the channel */
	channelId: string;
}

/**
 * @description ChannelCategoryUserPermission
 */
export interface ChannelCategoryUserPermission {
	/** @description permissions */
	permissions: Record<string, boolean>;
	/** @description The ISO 8601 timestamp that the permission override was created at */
	createdAt: string;
	/** @description The ISO 8601 timestamp that the permission override was updated at, if relevant */
	updatedAt?: string;
	/** @description The ID of the user */
	userId: string;
	/** @description The ID of the category */
	categoryId: number;
}

/**
 * @description ChannelCategoryRolePermission
 */
export interface ChannelCategoryRolePermission {
	/** @description permissions */
	permissions: Record<string, boolean>;
	/** @description The ISO 8601 timestamp that the permission override was created at */
	createdAt: string;
	/** @description The ISO 8601 timestamp that the permission override was updated at, if relevant */
	updatedAt?: string;
	/** @description The ID of the role */
	roleId: number;
	/** @description The ID of the category */
	categoryId: number;
}

/**
 * @description UrlSignature
 */
export interface UrlSignature {
	/** @description The URL that is to be signed */
	url: string;
	/** @description The url with a valid signature that has a 5 minute expiration on the signature */
	signature?: string;
	/** @description The number of seconds to wait before retrying the request */
	retryAfter?: number;
}

/** @description API operations */
export interface operations {
	/** Create a channel message */
	ChannelMessageCreate: {
		parameters: {
			path: {
				/** Channel ID to create the message in */
				channelId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					isPrivate?: boolean;
					isSilent?: boolean;
					replyMessageIds?: (string)[];
					content?: Record<string, unknown> | string;
					hiddenLinkPreviewUrls?: (string)[];
					embeds?: (ChatEmbed)[];
				};
			};
		};
		responses: {
			201: {
				/** Success */
				content: {
					'application/json': {
						message: ChatMessage;
					};
				};
			};
		};
	};
	/** Results returned will be ordered ascending by the message's `createdAt`. `before` and `after` will filter based on the message's `createdAt` */
	ChannelMessageReadMany: {
		parameters: {
			query: {
				/** before */
				before: string;
				/** An ISO 8601 timestamp that will be used to filter out results for the current page. Order will be reversed when compared to `before` or when omitting this parameter altogether */
				after: string;
				/** limit */
				limit: number;
				/** Whether to include private messages between all users in response */
				includePrivate: boolean;
			};
			path: {
				/** ID of the channel that the messages exist in */
				channelId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						messages: (ChatMessage)[];
					};
				};
			};
		};
	};
	/** Get details for a specific chat message from a chat channel. */
	ChannelMessageRead: {
		parameters: {
			path: {
				/** ID of the channel that the message exists in */
				channelId: string;
				/** messageId */
				messageId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						message: ChatMessage;
					};
				};
			};
		};
	};
	/** Update a channel message */
	ChannelMessageUpdate: {
		parameters: {
			path: {
				/** ID of the channel that the message to be updated exists in */
				channelId: string;
				/** messageId */
				messageId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					content?: Record<string, unknown> | string;
					hiddenLinkPreviewUrls?: (string)[];
					embeds?: (ChatEmbed)[];
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						message: {
							id?: string;
							type?: 'default' | 'system';
							serverId?: string;
							groupId?: string;
							channelId?: string;
							content?: string;
							hiddenLinkPreviewUrls?: (string)[];
							embeds?: (ChatEmbed)[];
							replyMessageIds?: (string)[];
							isPrivate?: boolean;
							isSilent?: boolean;
							isPinned?: boolean;
							mentions?: Mentions;
							createdAt?: string;
							createdBy?: string;
							createdByWebhookId?: string;
							updatedAt: string;
						} & (ChatMessage);
					};
				};
			};
		};
	};
	/** Delete a channel message */
	ChannelMessageDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** messageId */
				messageId: string;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Add member to group */
	GroupMembershipCreate: {
		parameters: {
			path: {
				/** Group ID to add the member to */
				groupId: string;
				/** Member ID to add to the group */
				userId: string & (string | '@me');
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Remove member from group */
	GroupMembershipDelete: {
		parameters: {
			path: {
				/** Group ID to remove the member from */
				groupId: string;
				/** Member ID to remove from the group */
				userId: string & (string | '@me');
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Award XP to a member */
	ServerXpForUserCreate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** Member ID to award XP to */
				userId: string & (string | '@me');
			};
		};
		requestBody: {
			content: {
				'application/json': {
					amount: number;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						total: number;
					};
				};
			};
		};
	};
	/** Set a member's XP */
	ServerXpForUserUpdate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** Member ID to set XP to */
				userId: string & (string | '@me');
			};
		};
		requestBody: {
			content: {
				'application/json': {
					total: number;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						total: number;
					};
				};
			};
		};
	};
	/** Take note of the max number of `userIds` that can be submitted on each request. If you require more, please batch your requests */
	ServerXpForUserCreateMany: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					amount: number;
					userIds: (string & (string | '@me'))[];
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						totalsByUserId: Record<string, number>;
					};
				};
			};
		};
	};
	/** Take note of the max number of `userIds` that can be submitted on each request. If you require more, please batch your requests */
	ServerXpForUserUpdateMany: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					amount: number;
					userIds: (string & (string | '@me'))[];
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						totalsByUserId: Record<string, number>;
					};
				};
			};
		};
	};
	/** Award XP to all members with a particular role. */
	ServerXpForRoleCreate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** Role ID to award XP to */
				roleId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					amount: number;
				};
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Assign role to member */
	RoleMembershipCreate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** The ID of the member that the role should be assigned to */
				userId: string & (string | '@me');
				/** The role ID to apply to the user */
				roleId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Remove role from member */
	RoleMembershipDelete: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** The ID of the member that the role should be removed from */
				userId: string & (string | '@me');
				/** The role ID to remove from the user */
				roleId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Get a list of the roles assigned to a member */
	RoleMembershipReadMany: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** The ID of the member to obtain roles from */
				userId: string & (string | '@me');
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						roleIds: (number)[];
					};
				};
			};
		};
	};
	/** Create a topic in a forum */
	ForumTopicCreate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					title: string;
					content: Record<string, unknown> | string;
				};
			};
		};
		responses: {
			201: {
				/** Success */
				content: {
					'application/json': {
						forumTopic: ForumTopic;
					};
				};
			};
		};
	};
	/** Get forum topics */
	ForumTopicReadMany: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
			};
			query: {
				/** before */
				before: string;
				/** limit */
				limit: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						forumTopics: (ForumTopicSummary)[];
					};
				};
			};
		};
	};
	/** Get a forum topic */
	ForumTopicRead: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** forumTopicId */
				forumTopicId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						forumTopic: ForumTopic;
					};
				};
			};
		};
	};
	/** Update a forum topic */
	ForumTopicUpdate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** forumTopicId */
				forumTopicId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					title?: string;
					content?: string;
				};
			};
		};
		responses: {
			201: {
				/** Success */
				content: {
					'application/json': {
						forumTopic: ForumTopic;
					};
				};
			};
		};
	};
	/** Delete a forum topic */
	ForumTopicDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** forumTopicId */
				forumTopicId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Pin a forum topic */
	ForumTopicPin: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** forumTopicId */
				forumTopicId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Unpin a forum topic */
	ForumTopicUnpin: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** forumTopicId */
				forumTopicId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Create forum topic reaction */
	ForumTopicReactionCreate: {
		parameters: {
			path: {
				/** Channel ID where the forum topic exists */
				channelId: string;
				/** Forum Topic ID */
				forumTopicId: number;
				/** Emote ID to apply */
				emoteId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Delete forum topic reaction */
	ForumTopicReactionDelete: {
		parameters: {
			path: {
				/** Channel ID where the forum topic exists */
				channelId: string;
				/** Forum Topic ID */
				forumTopicId: number;
				/** Emote ID to remove */
				emoteId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Lock a forum topic */
	ForumTopicLock: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** forumTopicId */
				forumTopicId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Unlock a forum topic */
	ForumTopicUnlock: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** forumTopicId */
				forumTopicId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Create a forum topic comment */
	ForumTopicCommentCreate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** forumTopicId */
				forumTopicId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					content: string;
				};
			};
		};
		responses: {
			201: {
				/** Success */
				content: {
					'application/json': {
						forumTopicComment: ForumTopicComment;
					};
				};
			};
		};
	};
	/** Get a forum topic's comments */
	ForumTopicCommentReadMany: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** forumTopicId */
				forumTopicId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						forumTopicComments: (ForumTopicComment)[];
					};
				};
			};
		};
	};
	/** Get a comment on a forum topic */
	ForumTopicCommentRead: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** forumTopicId */
				forumTopicId: number;
				/** forumTopicCommentId */
				forumTopicCommentId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						forumTopicComment: ForumTopicComment;
					};
				};
			};
		};
	};
	/** Update a forum topic comment */
	ForumTopicCommentUpdate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** forumTopicId */
				forumTopicId: number;
				/** forumTopicCommentId */
				forumTopicCommentId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					content?: string;
				};
			};
		};
		responses: {
			201: {
				/** Success */
				content: {
					'application/json': {
						forumTopicComment: ForumTopicComment;
					};
				};
			};
		};
	};
	/** Delete a forum topic comment */
	ForumTopicCommentDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** forumTopicId */
				forumTopicId: number;
				/** forumTopicCommentId */
				forumTopicCommentId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Create a list item */
	ListItemCreate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					message: Record<string, unknown> | string;
					note?: {
						content: Record<string, unknown> | string;
					};
				};
			};
		};
		responses: {
			201: {
				/** Success */
				content: {
					'application/json': {
						listItem: ListItem;
					};
				};
			};
		};
	};
	/** Get list items within a channel */
	ListItemReadMany: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						listItems: (ListItemSummary)[];
					};
				};
			};
		};
	};
	/** Get a list item */
	ListItemRead: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** listItemId */
				listItemId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						listItem: ListItem;
					};
				};
			};
		};
	};
	/** Update a list item */
	ListItemUpdate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** listItemId */
				listItemId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					message?: string;
					note?: {
						content: string;
					};
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						listItem: ListItem;
					};
				};
			};
		};
	};
	/** Delete a list item */
	ListItemDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** listItemId */
				listItemId: string;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Complete a list item */
	ListItemCompleteCreate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** listItemId */
				listItemId: string;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Uncomplete a list item */
	ListItemCompleteDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** listItemId */
				listItemId: string;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Retrieves a member's public social links */
	MemberSocialLinkRead: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** userId */
				userId: string & (string | '@me');
				/** The type of social link to retrieve */
				socialLinkType:
					| 'twitch'
					| 'bnet'
					| 'psn'
					| 'xbox'
					| 'steam'
					| 'origin'
					| 'youtube'
					| 'twitter'
					| 'facebook'
					| 'switch'
					| 'patreon'
					| 'roblox'
					| 'epic';
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						socialLink: SocialLink;
					};
				};
			};
		};
	};
	/** Update a member's nickname */
	MemberNicknameUpdate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** The ID of the user to update nickname for */
				userId: string & (string | '@me');
			};
		};
		requestBody: {
			content: {
				'application/json': {
					nickname: string;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						nickname: string;
					};
				};
			};
		};
	};
	/** Delete a member's nickname */
	MemberNicknameDelete: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** The ID of the user to remove nickname from */
				userId: string & (string | '@me');
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Only server channels are supported at this time (coming soon: DM Channels!). By default, a channel will be created with a null value for priority on a server. You can update its priority using [the channel update route](/docs/api/channels/ChannelUpdate) */
	ChannelCreate: {
		requestBody: {
			content: {
				'application/json': {
					name: string;
					topic?: string;
					visibility?: null | 'private' | 'public';
					type:
						| 'announcements'
						| 'chat'
						| 'calendar'
						| 'forums'
						| 'media'
						| 'docs'
						| 'voice'
						| 'list'
						| 'scheduling'
						| 'stream';
					serverId?: string;
					groupId?: string;
					categoryId?: number;
					parentId?: string;
					messageId?: string;
				};
			};
		};
		responses: {
			201: {
				/** Success */
				content: {
					'application/json': {
						channel: ServerChannel;
					};
				};
			};
		};
	};
	/** Must be a member of the server to get the channel. Only server channels are supported at this time (coming soon: DM Channels!) */
	ChannelRead: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						channel: ServerChannel;
					};
				};
			};
		};
	};
	/** Only server channels are supported at this time (coming soon: DM Channels!) */
	ChannelUpdate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					name?: string;
					topic?: string;
					visibility?: null | 'public';
					priority?: number;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						channel: ServerChannel;
					};
				};
			};
		};
	};
	/** Only server channels are supported at this time (coming soon: DM Channels!) */
	ChannelDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Create a doc */
	DocCreate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					title: string;
					content: Record<string, unknown> | string;
				};
			};
		};
		responses: {
			201: {
				/** Success */
				content: {
					'application/json': {
						doc: Doc;
					};
				};
			};
		};
	};
	/** Results returned will be ordered descending by the doc's `updatedAt`. `before` will filter based on the doc's `updatedAt` */
	DocReadMany: {
		parameters: {
			query: {
				/** before */
				before: string;
				/** limit */
				limit: number;
			};
			path: {
				/** channelId */
				channelId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						docs: (Doc)[];
					};
				};
			};
		};
	};
	/** Get a doc */
	DocRead: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** docId */
				docId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						doc: Doc;
					};
				};
			};
		};
	};
	/** Update a doc */
	DocUpdate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** docId */
				docId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					title: string;
					content: string;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						doc: Doc;
					};
				};
			};
		};
	};
	/** Delete a doc */
	DocDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** docId */
				docId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Get a server member */
	ServerMemberRead: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** userId */
				userId: string & (string | '@me');
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						member: ServerMember;
					};
				};
			};
		};
	};
	/** This route can be used to leave servers by passing in your own user ID or `@me` for `userId` */
	ServerMemberDelete: {
		parameters: {
			path: {
				/** The ID of the server to kick the user from */
				serverId: string;
				/** The ID of the user to kick. If the value provided here is your own user's ID, the request will attempt to make you leave the server */
				userId: string & (string | '@me');
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Results returned will be ordered ascending by the member's `joinedAt` */
	ServerMemberReadMany: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						members: (ServerMemberSummary)[];
					};
				};
			};
		};
	};
	/** Also known as banning a server member */
	ServerMemberBanCreate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** The ID of the user to ban from this server */
				userId: string & (string | '@me');
			};
		};
		requestBody: {
			content: {
				'application/json': {
					reason?: string;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						serverMemberBan: ServerMemberBan;
					};
				};
			};
		};
	};
	/** Get a server ban */
	ServerMemberBanRead: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** The ID of the user to get a server ban for */
				userId: string & (string | '@me');
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						serverMemberBan: ServerMemberBan;
					};
				};
			};
		};
	};
	/** Also known as unbanning a server member */
	ServerMemberBanDelete: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** The ID of the user to unban from this server */
				userId: string & (string | '@me');
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Get server bans */
	ServerMemberBanReadMany: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						serverMemberBans: (ServerMemberBan)[];
					};
				};
			};
		};
	};
	/** Note that each server can only have 200 webhooks */
	WebhookCreate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					name: string;
					channelId: string;
				};
			};
		};
		responses: {
			201: {
				/** Success */
				content: {
					'application/json': {
						webhook: Webhook;
					};
				};
			};
		};
	};
	/** Get a list of webhooks from a server. */
	WebhookReadMany: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
			};
			query: {
				/** ID of the channel you want to filter for webhooks */
				channelId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						webhooks: (Webhook)[];
					};
				};
			};
		};
	};
	/** Get a server's webhook */
	WebhookRead: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** webhookId */
				webhookId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						webhook: Webhook;
					};
				};
			};
		};
	};
	/** Update a webhook */
	WebhookUpdate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** webhookId */
				webhookId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					name: string;
					channelId?: string;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						webhook: Webhook;
					};
				};
			};
		};
	};
	/** Delete a server webhook */
	WebhookDelete: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** webhookId */
				webhookId: string;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Fetch various information about a given server. Currently, the bot must be a member of the server in order to fetch its information. */
	ServerRead: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						server: Server;
						serverMemberCount: number;
					};
				};
			};
		};
	};
	/** We currently do not have a way to surface the `repeatInfo` after event series are updated. Stay tuned! */
	CalendarEventCreate: {
		parameters: {
			path: {
				/** The calendar to create the event in */
				channelId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					name: string;
					description?: string;
					location?: string;
					startsAt?: string;
					url?: string;
					color?: number;
					isAllDay?: boolean;
					rsvpDisabled?: boolean;
					rsvpLimit?: number;
					autofillWaitlist?: boolean;
					duration?: number;
					isPrivate?: boolean;
					roleIds?: (number)[];
					repeatInfo?: {
						type: 'once' | 'everyDay' | 'everyWeek' | 'everyMonth' | 'custom';
						every?: {
							count: number;
							interval: 'day' | 'month' | 'year' | 'week';
						};
						endsAfterOccurrences?: number;
						endDate?: string;
						on?: (
							| 'sunday'
							| 'monday'
							| 'tuesday'
							| 'wednesday'
							| 'thursday'
							| 'friday'
							| 'saturday'
						)[];
					};
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						calendarEvent: CalendarEvent;
					};
				};
			};
		};
	};
	/** Results returned will be ordered ascending by the event's `startsAt`. `before` and `after` will filter based on the event's `startsAt` */
	CalendarEventReadMany: {
		parameters: {
			query: {
				/** before */
				before: string;
				/** after */
				after: string;
				/** limit */
				limit: number;
			};
			path: {
				/** channelId */
				channelId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						calendarEvents: (CalendarEvent)[];
					};
				};
			};
		};
	};
	/** Get a calendar event */
	CalendarEventRead: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventId */
				calendarEventId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						calendarEvent: CalendarEvent;
					};
				};
			};
		};
	};
	/** We currently do not have a way to surface the `repeatInfo` after event series are updated. Stay tuned! */
	CalendarEventUpdate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventId */
				calendarEventId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					name?: string;
					description?: string;
					location?: string;
					startsAt?: string;
					url?: string;
					color?: number;
					isAllDay?: boolean;
					rsvpDisabled?: boolean;
					rsvpLimit?: number;
					autofillWaitlist?: boolean;
					duration?: number;
					isPrivate?: boolean;
					roleIds?: (number)[];
					cancellation?: {
						description?: string;
					};
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						calendarEvent: CalendarEvent;
					};
				};
			};
		};
	};
	/** Delete a calendar event */
	CalendarEventDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventId */
				calendarEventId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Get a calendar event RSVP */
	CalendarEventRsvpRead: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventId */
				calendarEventId: number;
				/** userId */
				userId: string & (string | '@me');
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						calendarEventRsvp: CalendarEventRsvp;
					};
				};
			};
		};
	};
	/** Create or update a calendar event RSVP */
	CalendarEventRsvpUpdate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventId */
				calendarEventId: number;
				/** userId */
				userId: string & (string | '@me');
			};
		};
		requestBody: {
			content: {
				'application/json': {
					status: 'going' | 'maybe' | 'declined' | 'invited';
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						calendarEventRsvp: CalendarEventRsvp;
					};
				};
			};
		};
	};
	/** Delete a calendar event RSVP */
	CalendarEventRsvpDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventId */
				calendarEventId: number;
				/** userId */
				userId: string & (string | '@me');
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Get calendar event RSVPs */
	CalendarEventRsvpReadMany: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventId */
				calendarEventId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						calendarEventRsvps: (CalendarEventRsvp)[];
					};
				};
			};
		};
	};
	/** Create or update a calendar event RSVP for multiple users */
	CalendarEventRsvpUpdateMany: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventId */
				calendarEventId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					userIds: (string & (string | '@me'))[];
					status: 'going' | 'maybe' | 'declined' | 'invited';
				};
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** **Note** - at this time, you can only retrieve your own user */
	UserRead: {
		parameters: {
			path: {
				/** userId */
				userId: string & (string | '@me');
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						user: User;
					};
				};
			};
		};
	};
	/** Create forum topic comment reaction */
	ForumTopicCommentReactionCreate: {
		parameters: {
			path: {
				/** Channel ID where the forum topic exists */
				channelId: string;
				/** forumTopicId */
				forumTopicId: number;
				/** forumTopicCommentId */
				forumTopicCommentId: number;
				/** emoteId */
				emoteId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Delete forum topic comment reaction */
	ForumTopicCommentReactionDelete: {
		parameters: {
			path: {
				/** Channel ID where the forum topic exists */
				channelId: string;
				/** forumTopicId */
				forumTopicId: number;
				/** forumTopicCommentId */
				forumTopicCommentId: number;
				/** emoteId */
				emoteId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Create a comment on a calendar event */
	CalendarEventCommentCreate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventId */
				calendarEventId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					content: string;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						calendarEventComment: CalendarEventComment;
					};
				};
			};
		};
	};
	/** Get a calendar event's comments */
	CalendarEventCommentReadMany: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventId */
				calendarEventId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						calendarEventComments: (CalendarEventComment)[];
					};
				};
			};
		};
	};
	/** Get a comment on the calendar event */
	CalendarEventCommentRead: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventId */
				calendarEventId: number;
				/** calendarEventCommentId */
				calendarEventCommentId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						calendarEventComment: CalendarEventComment;
					};
				};
			};
		};
	};
	/** Update a calendar event comment */
	CalendarEventCommentUpdate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventId */
				calendarEventId: number;
				/** calendarEventCommentId */
				calendarEventCommentId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					content: string;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						calendarEventComment: CalendarEventComment;
					};
				};
			};
		};
	};
	/** Delete a calendar event comment */
	CalendarEventCommentDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventId */
				calendarEventId: number;
				/** calendarEventCommentId */
				calendarEventCommentId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Create calendar event reaction */
	CalendarEventReactionCreate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventId */
				calendarEventId: number;
				/** emoteId */
				emoteId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Delete calendar event reaction */
	CalendarEventReactionDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventId */
				calendarEventId: number;
				/** emoteId */
				emoteId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Create calendar event comment reaction */
	CalendarEventCommentReactionCreate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventId */
				calendarEventId: number;
				/** calendarEventCommentId */
				calendarEventCommentId: number;
				/** emoteId */
				emoteId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Delete calendar event comment reaction */
	CalendarEventCommentReactionDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventId */
				calendarEventId: number;
				/** calendarEventCommentId */
				calendarEventCommentId: number;
				/** emoteId */
				emoteId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Create a comment on a doc */
	DocCommentCreate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** docId */
				docId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					content: string;
				};
			};
		};
		responses: {
			201: {
				/** Success */
				content: {
					'application/json': {
						docComment: DocComment;
					};
				};
			};
		};
	};
	/** Get a doc's comments */
	DocCommentReadMany: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** docId */
				docId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						docComments: (DocComment)[];
					};
				};
			};
		};
	};
	/** Get a comment on a doc */
	DocCommentRead: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** docId */
				docId: number;
				/** docCommentId */
				docCommentId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						docComment: DocComment;
					};
				};
			};
		};
	};
	/** Update a doc comment */
	DocCommentUpdate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** docId */
				docId: number;
				/** docCommentId */
				docCommentId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					content: string;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						docComment: DocComment;
					};
				};
			};
		};
	};
	/** Delete a doc comment */
	DocCommentDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** docId */
				docId: number;
				/** docCommentId */
				docCommentId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Create doc reaction */
	DocReactionCreate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** docId */
				docId: number;
				/** emoteId */
				emoteId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Delete doc reaction */
	DocReactionDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** docId */
				docId: number;
				/** emoteId */
				emoteId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Create doc comment reaction */
	DocCommentReactionCreate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** docId */
				docId: number;
				/** docCommentId */
				docCommentId: number;
				/** emoteId */
				emoteId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Delete doc comment reaction */
	DocCommentReactionDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** docId */
				docId: number;
				/** docCommentId */
				docCommentId: number;
				/** emoteId */
				emoteId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Update a calendar event series */
	CalendarEventSeriesUpdate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventSeriesId */
				calendarEventSeriesId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					name?: string;
					description?: string;
					location?: string;
					startsAt?: string;
					url?: string;
					color?: number;
					isAllDay?: boolean;
					rsvpDisabled?: boolean;
					rsvpLimit?: number;
					autofillWaitlist?: boolean;
					duration?: number;
					isPrivate?: boolean;
					roleIds?: (number)[];
					repeatInfo?: {
						type: 'once' | 'everyDay' | 'everyWeek' | 'everyMonth' | 'custom';
						every?: {
							count: number;
							interval: 'day' | 'month' | 'year' | 'week';
						};
						endsAfterOccurrences?: number;
						endDate?: string;
						on?: (
							| 'sunday'
							| 'monday'
							| 'tuesday'
							| 'wednesday'
							| 'thursday'
							| 'friday'
							| 'saturday'
						)[];
					};
					calendarEventId?: number;
				};
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Delete a calendar event series */
	CalendarEventSeriesDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** calendarEventSeriesId */
				calendarEventSeriesId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					calendarEventId?: number;
				};
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Create an announcement */
	AnnouncementCreate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					title: string;
					content: Record<string, unknown> | string;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						announcement: Announcement;
					};
				};
			};
		};
	};
	/** Results returned will be ordered ascending by the announcement's `createdAt`. `before` will filter based on the announcement's `createdAt` */
	AnnouncementReadMany: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
			};
			query: {
				/** before */
				before: string;
				/** limit */
				limit: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						announcements: (Announcement)[];
					};
				};
			};
		};
	};
	/** Read an announcement */
	AnnouncementRead: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** announcementId */
				announcementId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						announcement: Announcement;
					};
				};
			};
		};
	};
	/** Update an announcement */
	AnnouncementUpdate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** announcementId */
				announcementId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					title?: string;
					content?: Record<string, unknown> | string;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						announcement: Announcement;
					};
				};
			};
		};
	};
	/** Delete an announcement */
	AnnouncementDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** announcementId */
				announcementId: string;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** **Note** - at this time, you can only retrieve your own servers */
	UserServerReadMany: {
		parameters: {
			path: {
				/** userId */
				userId: string & (string | '@me');
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						servers: (Server)[];
					};
				};
			};
		};
	};
	/** Create announcement reaction */
	AnnouncementReactionCreate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** announcementId */
				announcementId: string;
				/** Emote ID to apply */
				emoteId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Delete announcement reaction */
	AnnouncementReactionDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** announcementId */
				announcementId: string;
				/** Emote ID to apply */
				emoteId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Create a comment on an announcement */
	AnnouncementCommentCreate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** announcementId */
				announcementId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					content: string;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						announcementComment: AnnouncementComment;
					};
				};
			};
		};
	};
	/** Get an announcement's comments */
	AnnouncementCommentReadMany: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** announcementId */
				announcementId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						announcementComments: (AnnouncementComment)[];
					};
				};
			};
		};
	};
	/** Get a comment on the announcement */
	AnnouncementCommentRead: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** announcementId */
				announcementId: string;
				/** announcementCommentId */
				announcementCommentId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						announcementComment: AnnouncementComment;
					};
				};
			};
		};
	};
	/** Update an announcement comment */
	AnnouncementCommentUpdate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** announcementId */
				announcementId: string;
				/** announcementCommentId */
				announcementCommentId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					content: string;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						announcementComment: AnnouncementComment;
					};
				};
			};
		};
	};
	/** Delete an announcement comment */
	AnnouncementCommentDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** announcementId */
				announcementId: string;
				/** announcementCommentId */
				announcementCommentId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Create an announcement comment reaction */
	AnnouncementCommentReactionCreate: {
		parameters: {
			path: {
				/** Channel ID where the announcement comment exists */
				channelId: string;
				/** announcementId */
				announcementId: string;
				/** announcementCommentId */
				announcementCommentId: number;
				/** Emote ID to apply */
				emoteId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Delete an announcement comment reaction */
	AnnouncementCommentReactionDelete: {
		parameters: {
			path: {
				/** Channel ID where the announcement comment exists */
				channelId: string;
				/** announcementId */
				announcementId: string;
				/** announcementCommentId */
				announcementCommentId: number;
				/** Emote ID to apply */
				emoteId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** This value can be a max of 24 hours into the future. If you are wanting a longer expiration, set this value to null so that it never expires. **Note** - at this time, you can only set a status on your own user */
	UserStatusCreate: {
		parameters: {
			path: {
				/** userId */
				userId: string & (string | '@me');
			};
		};
		requestBody: {
			content: {
				'application/json': {
					content?: string;
					emoteId: number;
					expiresAt?: string;
				};
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** **Note** - at this time, you can only set a status on your own user */
	UserStatusDelete: {
		parameters: {
			path: {
				/** userId */
				userId: string & (string | '@me');
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Create a message reaction */
	ChannelMessageReactionCreate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** messageId */
				messageId: string;
				/** emoteId */
				emoteId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Delete a message reaction */
	ChannelMessageReactionDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** messageId */
				messageId: string;
				/** emoteId */
				emoteId: number;
			};
			query: {
				/** userId */
				userId: string & (string | '@me');
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Bulk delete a message's reactions */
	ChannelMessageReactionDeleteMany: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** messageId */
				messageId: string;
			};
			query: {
				/** emoteId */
				emoteId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Note: only 100 unarchived groups can exist on a server at any time */
	GroupCreate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					name: string;
					description?: string;
					emoteId?: number;
					isPublic?: boolean;
				};
			};
		};
		responses: {
			201: {
				/** Success */
				content: {
					'application/json': {
						group: Group;
					};
				};
			};
		};
	};
	/** Get groups */
	GroupReadMany: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						groups: (Group)[];
					};
				};
			};
		};
	};
	/** Get a group */
	GroupRead: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** groupId */
				groupId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						group: Group;
					};
				};
			};
		};
	};
	/** Update a group */
	GroupUpdate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** groupId */
				groupId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					name?: string;
					description?: string;
					emoteId?: number;
					isPublic?: boolean;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						group: Group;
					};
				};
			};
		};
	};
	/** Note: you cannot delete the home group */
	GroupDelete: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** groupId */
				groupId: string;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** By default, a role will be created with the lowest priority on a server. You can update its priority using [the role update route](/docs/api/roles/RoleUpdate) */
	RoleCreate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					name: string;
					isDisplayedSeparately?: boolean;
					isSelfAssignable?: boolean;
					isMentionable?: boolean;
					permissions: (string)[];
					colors?: (number)[];
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						role: Role;
					};
				};
			};
		};
	};
	/** Get roles */
	RoleReadMany: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						roles: (Role)[];
					};
				};
			};
		};
	};
	/** Get a role */
	RoleRead: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** roleId */
				roleId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						role: Role;
					};
				};
			};
		};
	};
	/** Note that when a `priority` is updated, there will still only be a socket event for the role that was touched directly and not for other roles that were shifted */
	RoleUpdate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** roleId */
				roleId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					name?: string;
					isDisplayedSeparately?: boolean;
					isSelfAssignable?: boolean;
					isMentionable?: boolean;
					permissions?: (string)[];
					priority?: number;
					colors?: (number)[];
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						role: Role;
					};
				};
			};
		};
	};
	/** Delete a role */
	RoleDelete: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** roleId */
				roleId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						role: Role;
					};
				};
			};
		};
	};
	/** Update a role permission */
	RolePermissionUpdate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** roleId */
				roleId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					permissions: Record<string, unknown>;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						role: Role;
					};
				};
			};
		};
	};
	/** Get a server subscription tier */
	ServerSubscriptionTierRead: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** serverSubscriptionTierType */
				serverSubscriptionTierType: 'Gold' | 'Silver' | 'Copper';
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						serverSubscriptionTier: ServerSubscriptionTier;
					};
				};
			};
		};
	};
	/** Get server subscription tiers */
	ServerSubscriptionTierReadMany: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						serverSubscriptionTiers: (ServerSubscriptionTier)[];
					};
				};
			};
		};
	};
	/** If the user has *all* of the permissions passed, the HTTP status code will be 200; if user is missing one or more permissions passed, the HTTP status code will be [418](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/418) with a `meta` property containing `missingPermissions` of the permissions the user does not have (this is a 418 to differentiate from a 403 if the _bot_ did not have permissions to perform the request, not the _user_). Tip: Use the `HEAD` HTTP method for this route if you only care about if the user has permissions and not the response body containing what's missing. */
	ServerMemberPermissionsRead: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** userId */
				userId: string & (string | '@me');
			};
			query: {
				/** A queryString array of `ids[]` representing [Enums/Permissions](https://www.guilded.gg/docs/api/Permissions) */
				ids: (
					| 'CanCreateTopics'
					| 'CanCreateTopicReplies'
					| 'CanDeleteTopics'
					| 'CanStickyTopics'
					| 'CanLockTopics'
					| 'CanManageEmotes'
					| 'CanViewFormResponses'
					| 'CanUpdateListItems'
					| 'CanManageServerXp'
					| 'CanCreateThreads'
					| 'CanCreateThreadMessages'
					| 'CanManageThreads'
					| 'CanCreateAnnouncements'
					| 'CanUpdateServer'
					| 'CanManageRoles'
					| 'CanInviteMembers'
					| 'CanKickMembers'
					| 'CanManageGroups'
					| 'CanManageChannels'
					| 'CanManageWebhooks'
					| 'CanMentionEveryone'
					| 'CanModerateChannels'
					| 'CanBypassSlowMode'
					| 'CanReadApplications'
					| 'CanApproveApplications'
					| 'CanEditApplicationForm'
					| 'CanIndicateLfmInterest'
					| 'CanModifyLfmStatus'
					| 'CanReadAnnouncements'
					| 'CanManageAnnouncements'
					| 'CanReadChats'
					| 'CanCreateChats'
					| 'CanUploadChatMedia'
					| 'CanCreatePrivateMessages'
					| 'CanManageChats'
					| 'CanReadEvents'
					| 'CanCreateEvents'
					| 'CanEditEvents'
					| 'CanDeleteEvents'
					| 'CanEditEventRsvps'
					| 'CanReadForums'
					| 'CanReadDocs'
					| 'CanCreateDocs'
					| 'CanEditDocs'
					| 'CanDeleteDocs'
					| 'CanReadMedia'
					| 'CanAddMedia'
					| 'CanEditMedia'
					| 'CanDeleteMedia'
					| 'CanListenVoice'
					| 'CanAddVoice'
					| 'CanManageVoiceGroups'
					| 'CanAssignVoiceGroup'
					| 'CanBroadcastVoice'
					| 'CanDirectVoice'
					| 'CanPrioritizeVoice'
					| 'CanUseVoiceActivity'
					| 'CanMuteMembers'
					| 'CanDeafenMembers'
					| 'CanSendVoiceMessages'
					| 'CanCreateScrims'
					| 'CanManageTournaments'
					| 'CanRegisterForTournaments'
					| 'CanChangeNickname'
					| 'CanManageNicknames'
					| 'CanViewPollResponses'
					| 'CanReadListItems'
					| 'CanCreateListItems'
					| 'CanDeleteListItems'
					| 'CanCompleteListItems'
					| 'CanReorderListItems'
					| 'CanViewBracket'
					| 'CanReportScores'
					| 'CanReadSchedules'
					| 'CanCreateSchedule'
					| 'CanDeleteSchedule'
					| 'CanManageBots'
					| 'CanReadStreams'
					| 'CanJoinStreamVoice'
					| 'CanCreateStreams'
					| 'CanSendStreamMessages'
					| 'CanAddStreamVoice'
					| 'CanUseVoiceActivityInStream'
					| 'CanReceiveAllSocketEvents'
				)[];
				/** channelId */
				channelId: string;
				/** categoryId */
				categoryId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						permissions: (string)[];
					};
				};
			};
		};
	};
	/** Archive a channel */
	ChannelArchiveCreate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Restore an archived channel */
	ChannelArchiveDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Create a category */
	CategoryCreate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					name: string;
					groupId?: string;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						category: Category;
					};
				};
			};
		};
	};
	/** Read a category */
	CategoryRead: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** categoryId */
				categoryId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						category: Category;
					};
				};
			};
		};
	};
	/** Update a category */
	CategoryUpdate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** categoryId */
				categoryId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					name?: string;
					priority?: number;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						category: Category;
					};
				};
			};
		};
	};
	/** Delete a category */
	CategoryDelete: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** categoryId */
				categoryId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						category: Category;
					};
				};
			};
		};
	};
	/** Pin a message */
	ChannelMessagePinCreate: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** messageId */
				messageId: string;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Unpin a message */
	ChannelMessagePinDelete: {
		parameters: {
			path: {
				/** channelId */
				channelId: string;
				/** messageId */
				messageId: string;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Create a channel role permission */
	ChannelRolePermissionCreate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** channelId */
				channelId: string;
				/** roleId */
				roleId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					permissions: Record<string, unknown>;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						channelRolePermission: ChannelRolePermission;
					};
				};
			};
		};
	};
	/** Read a channel role permission */
	ChannelRolePermissionRead: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** channelId */
				channelId: string;
				/** roleId */
				roleId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						channelRolePermission: ChannelRolePermission;
					};
				};
			};
		};
	};
	/** Update a channel role permission */
	ChannelRolePermissionUpdate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** channelId */
				channelId: string;
				/** roleId */
				roleId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					permissions: Record<string, unknown>;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						channelRolePermission: ChannelRolePermission;
					};
				};
			};
		};
	};
	/** Delete a channel role permission */
	ChannelRolePermissionDelete: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** channelId */
				channelId: string;
				/** roleId */
				roleId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** ReadMany a channel role permission */
	ChannelRolePermissionReadMany: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** channelId */
				channelId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						channelRolePermissions: (ChannelRolePermission)[];
					};
				};
			};
		};
	};
	/** Create a channel user permission */
	ChannelUserPermissionCreate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** channelId */
				channelId: string;
				/** userId */
				userId: string & (string | '@me');
			};
		};
		requestBody: {
			content: {
				'application/json': {
					permissions: Record<string, unknown>;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						channelUserPermission: ChannelUserPermission;
					};
				};
			};
		};
	};
	/** Read a channel user permission */
	ChannelUserPermissionRead: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** channelId */
				channelId: string;
				/** userId */
				userId: string & (string | '@me');
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						channelUserPermission: ChannelUserPermission;
					};
				};
			};
		};
	};
	/** Update a channel user permission */
	ChannelUserPermissionUpdate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** channelId */
				channelId: string;
				/** userId */
				userId: string & (string | '@me');
			};
		};
		requestBody: {
			content: {
				'application/json': {
					permissions: Record<string, unknown>;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						channelUserPermission: ChannelUserPermission;
					};
				};
			};
		};
	};
	/** Delete a channel user permission */
	ChannelUserPermissionDelete: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** channelId */
				channelId: string;
				/** userId */
				userId: string & (string | '@me');
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Read a channel user permission */
	ChannelUserPermissionReadMany: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** channelId */
				channelId: string;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						channelUserPermissions: (ChannelUserPermission)[];
					};
				};
			};
		};
	};
	/** Create a channel category user permission */
	ChannelCategoryUserPermissionCreate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** categoryId */
				categoryId: number;
				/** userId */
				userId: string & (string | '@me');
			};
		};
		requestBody: {
			content: {
				'application/json': {
					permissions: Record<string, unknown>;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						channelCategoryUserPermission: ChannelCategoryUserPermission;
					};
				};
			};
		};
	};
	/** Read a channel category user permission */
	ChannelCategoryUserPermissionRead: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** categoryId */
				categoryId: number;
				/** userId */
				userId: string & (string | '@me');
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						channelCategoryUserPermission: ChannelCategoryUserPermission;
					};
				};
			};
		};
	};
	/** Update a channel category user permission */
	ChannelCategoryUserPermissionUpdate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** categoryId */
				categoryId: number;
				/** userId */
				userId: string & (string | '@me');
			};
		};
		requestBody: {
			content: {
				'application/json': {
					permissions: Record<string, unknown>;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						channelCategoryUserPermission: ChannelCategoryUserPermission;
					};
				};
			};
		};
	};
	/** Delete a channel category user permission */
	ChannelCategoryUserPermissionDelete: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** categoryId */
				categoryId: number;
				/** userId */
				userId: string & (string | '@me');
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Get a list of the channel category user permissions */
	ChannelCategoryUserPermissionReadMany: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** categoryId */
				categoryId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						channelCategoryUserPermissions: (ChannelCategoryUserPermission)[];
					};
				};
			};
		};
	};
	/** Create a channel category role permission */
	ChannelCategoryRolePermissionCreate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** categoryId */
				categoryId: number;
				/** roleId */
				roleId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					permissions: Record<string, unknown>;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						channelCategoryRolePermission: ChannelCategoryRolePermission;
					};
				};
			};
		};
	};
	/** Read a channel category role permission */
	ChannelCategoryRolePermissionRead: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** categoryId */
				categoryId: number;
				/** roleId */
				roleId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						channelCategoryRolePermission: ChannelCategoryRolePermission;
					};
				};
			};
		};
	};
	/** Update a channel category role permission */
	ChannelCategoryRolePermissionUpdate: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** categoryId */
				categoryId: number;
				/** roleId */
				roleId: number;
			};
		};
		requestBody: {
			content: {
				'application/json': {
					permissions: Record<string, unknown>;
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						channelCategoryRolePermission: ChannelCategoryRolePermission;
					};
				};
			};
		};
	};
	/** Delete a channel category role permission */
	ChannelCategoryRolePermissionDelete: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** categoryId */
				categoryId: number;
				/** roleId */
				roleId: number;
			};
		};
		responses: {
			204: {
				/** Success */
				type: undefined;
			};
		};
	};
	/** Get a list of the channel category role permissions */
	ChannelCategoryRolePermissionReadMany: {
		parameters: {
			path: {
				/** serverId */
				serverId: string;
				/** categoryId */
				categoryId: number;
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						channelCategoryRolePermissions: (ChannelCategoryRolePermission)[];
					};
				};
			};
		};
	};
	/** User-uploaded content hosted on our CDN will no longer be accessible directly after June 30th, 2024. To access the content, you will need to generate a valid signature via the `/url-signatures` endpoint, which is valid for 5 minutes, and download the content to store the data. Each asset comes with a daily request limit of one, so make sure to save the assets accordingly. */
	UrlSignatureCreateMany: {
		requestBody: {
			content: {
				'application/json': {
					urls: (string)[];
				};
			};
		};
		responses: {
			200: {
				/** Success */
				content: {
					'application/json': {
						urlSignatures: (UrlSignature)[];
					};
				};
			};
		};
	};
}
